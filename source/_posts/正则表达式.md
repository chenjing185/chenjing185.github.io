---
title: 正则表达式
date: 2022-05-08 13:47:32
categories:
- JavaScript算法和数据结构
tags:
- JavaScript
- 正则表达式
toc: true
readmore: true
sticky: 0
comments: true
---
正则表达式，常常缩写为 “regex” 或 “regexp”，是帮助程序员匹配、搜索和替换文本的模式。正则表达式非常强大，但可能难以阅读，因为它们使用特殊字符来做更复杂更灵活的匹配。
<!-- more -->
## 使用测试方法
在编程语言中，正则表达式用于匹配指定的字符串。 通过正则表达式创建匹配模式（规则）可以帮你完成指定匹配。

如果想要在字符串 The dog chased the cat 中匹配到 the 这个单词，可以使用如下正则表达式：/the/。 注意，正则表达式中不需要引号。

JavaScript 中有多种使用正则表达式的方法。 测试正则表达式的一种方法是使用 .test() 方法。 .test() 方法会把编写的正则表达式和字符串（即括号内的内容）匹配，如果成功匹配到字符，则返回 true，反之，返回 false。
```html
<script>
let testStr = "freeCodeCamp";
let testRegex = /Code/;
testRegex.test(testStr);
</script>
```
test 方法会返回 true。
## 匹配文字字符串
在上一节中，使用正则表达式 /Hello/ 搜索到了字符串 Hello。 那个正则表达式在字符串中搜寻 Hello 的文字匹配。 下面是另一个在字符串中搜寻 Kevin 的示例：
```html
<script>
let testStr = "Hello, my name is Kevin.";
let testRegex = /Kevin/;
testRegex.test(testStr);
</script>
```
test 方法会返回 true。

任何其他形式的 Kevin 都不会被匹配。 例如，正则表达式 /Kevin/ 不会匹配 kevin 或者KEVIN。
```html
<script>
let wrongRegex = /kevin/;
wrongRegex.test(testStr);
</script>
```
此 test 调用将返回 false。
## 同时用多种模式匹配文字字符串
使用正则表达式/coding/，你可以在其他字符串中查找coding。

这对于搜寻单个字符串非常有用，但仅限于一种匹配模式。 你可以使用 alternation 或 OR 操作符搜索多个模式： |

此操作符匹配操作符前面或后面的字符。 例如，如果你想匹配 yes 或 no，你需要的正则表达式是 /yes|no/。

你还可以匹配多个规则，这可以通过添加更多的匹配模式来实现。 这些匹配模式将包含更多的 OR 操作符来分隔它们，比如/yes|no|maybe/。
## 匹配时忽略大小写
到目前为止，已经了解了如何用正则表达式来执行字符串的匹配。 但有时候，并不关注匹配字母的大小写。

大小写即大写字母和小写字母。 大写字母如 A、B 和 C。 小写字母如 a、b 和 c。

可以使用标志（flag）来匹配这两种情况。 标志有很多，不过这里我们只关注忽略大小写的标志——i。 可以通过将它附加到正则表达式之后来使用它。 这里给出使用该标志的一个实例 /ignorecase/i。 这个字符串可以匹配字符串 ignorecase、igNoreCase 和 IgnoreCase。
## 提取匹配项
到目前为止，只是检查了一个匹配模式是否存在于字符串中。 还可以使用 .match() 方法来提取找到的实际匹配项。

可以使用字符串来调用 .match() 方法，并在括号内传入正则表达式。

请看下面的举例：
```html
<script>
"Hello, World!".match(/Hello/);
let ourStr = "Regular expressions";
let ourRegex = /expressions/;
ourStr.match(ourRegex);
</script>
```
这里第一个 match 将返回 ["Hello"] 第二个将返回 ["expressions"]。

> 请注意， .match 语法是目前为止一直使用的 .test 方法中的“反向”：
```html
<script>
'string'.match(/regex/);
/regex/.test('string');
</script>
```
## 提取匹配项
到目前为止，只是检查了一个匹配模式是否存在于字符串中。 还可以使用 .match() 方法来提取找到的实际匹配项。

可以使用字符串来调用 .match() 方法，并在括号内传入正则表达式。

请看下面的举例：
```html
<script>
"Hello, World!".match(/Hello/);
let ourStr = "Regular expressions";
let ourRegex = /expressions/;
ourStr.match(ourRegex);
</script>
```
这里第一个 match 将返回 ["Hello"] 第二个将返回 ["expressions"]。

> 请注意， .match 语法是目前为止一直使用的 .test 方法中的“反向”：
```html
<script>
'string'.match(/regex/);
/regex/.test('string');
</script>
```
## 全局匹配
到目前为止，只能提取或搜寻一次模式匹配。
```html
<script>
let testStr = "Repeat, Repeat, Repeat";
let ourRegex = /Repeat/;
testStr.match(ourRegex);
</script>
```
在这里 match 将返回 ["Repeat"]。

若要多次搜寻或提取模式匹配，可以使用 g 标志。
```html
<script>
let repeatRegex = /Repeat/g;
testStr.match(repeatRegex);
</script>
```
这里 match 返回值 ["Repeat", "Repeat", "Repeat"]
## 用通配符匹配任何内容
有时不（或不需要）知道匹配模式中的确切字符。 如果要精确匹配到完整的单词，那出现一个拼写错误就会匹配不到。 幸运的是，可以使用通配符 . 来处理这种情况。

通配符 . 将匹配任何一个字符。 通配符也叫 dot 或 period。 可以像使用正则表达式中任何其他字符一样使用通配符。 例如，如果想匹配 hug、huh、hut 和 hum，可以使用正则表达式 /hu./ 匹配以上四个单词。
```html
<script>
let humStr = "I'll hum a song";
let hugStr = "Bear hug";
let huRegex = /hu./;
huRegex.test(humStr);
huRegex.test(hugStr);
</script>
```
上面的 test 都会返回 true。
## 将单个字符与多种可能性匹配
已经了解了文字匹配模式（/literal/）和通配符（/./）。 这是正则表达式的两种极端情况，一种是精确匹配，而另一种则是匹配所有。 在这两种极端情况之间有一个平衡选项。

可以使用字符集 （character classes）更灵活的匹配字符。 可以把字符集放在方括号（[ 和 ]）之间来定义一组需要匹配的字符串。

例如，如果想要匹配 bag、big 和 bug，但是不想匹配 bog。 可以创建正则表达式 /b[aiu]g/ 来执行此操作。 [aiu] 是只匹配字符 a、i 或者 u 的字符集。
```html
<script>
let bigStr = "big";
let bagStr = "bag";
let bugStr = "bug";
let bogStr = "bog";
let bgRegex = /b[aiu]g/;
bigStr.match(bgRegex);
bagStr.match(bgRegex);
bugStr.match(bgRegex);
bogStr.match(bgRegex);
</script>
```
按顺序排列，四次 match 调用将返回值 ["big"]、["bag"]、["bug"] 和 null。
## 匹配字母表中的字母
了解了如何使用字符集（character sets）来指定要匹配的一组字符串，但是有时需要匹配大量字符（例如，字母表中的每个字母）。 有一种写法可以让实现这个功能变得简短。

在字符集中，可以使用连字符（-）来定义要匹配的字符范围。

例如，要匹配小写字母 a 到 e，你可以使用 [a-e]。
```html
<script>
let catStr = "cat";
let batStr = "bat";
let matStr = "mat";
let bgRegex = /[a-e]at/;
catStr.match(bgRegex);
batStr.match(bgRegex);
matStr.match(bgRegex);
</script>
```
按顺序排列，三次 match 调用将返回值 ["cat"]，["bat"] 和 null。
## 匹配字母表中的数字和字母
使用连字符（-）匹配字符范围并不仅限于字母。 它还可以匹配一系列数字。

例如，/[0-5]/ 匹配 0 和 5 之间的任意数字，包含 0 和 5。

此外，还可以在单个字符集中组合一系列字母和数字。
```html
<script>
let jennyStr = "Jenny8675309";
let myRegex = /[a-z0-9]/ig;
jennyStr.match(myRegex);
</script>
```
## 匹配单个未指定的字符
到目前为止，已经创建了一个想要匹配的字符集合，但也可以创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集（ negated character sets）。

要创建否定字符集，需要在开始括号后面和不想匹配的字符前面放置脱字符（即^）。

例如，/[^aeiou]/gi 匹配所有非元音字符。 注意，字符 .、!、[、@、/ 和空白字符等也会被匹配，该否定字符集仅排除元音字符。
## 匹配出现一次或多次的字符
有时，需要匹配出现一次或者连续多次的的字符（或字符组）。 这意味着它至少出现一次，并且可能重复出现。

可以使用 + 符号来检查情况是否如此。 记住，字符或匹配模式必须一个接一个地连续出现。 这就是说，字符必须一个接一个地重复。

例如，/a+/g 会在 abc 中匹配到一个匹配项，并且返回 ["a"]。 因为 + 的存在，它也会在 aabc 中匹配到一个匹配项，然后返回 ["aa"]。

如果它是检查字符串 abab，它将匹配到两个匹配项并且返回["a", "a"]，因为a字符不连续，在它们之间有一个b字符。 最后，因为在字符串 bcd 中没有 a，因此找不到匹配项。
## 匹配出现零次或多次的字符
上一节中使用了加号 + 来查找出现一次或多次的字符。 还有一个选项可以匹配出现零次或多次的字符。

执行该操作的字符叫做星号，即*。
```html
<script>
let soccerWord = "gooooooooal!";
let gPhrase = "gut feeling";
let oPhrase = "over the moon";
let goRegex = /go*/;
soccerWord.match(goRegex);
gPhrase.match(goRegex);
oPhrase.match(goRegex);
</script>
```
按顺序排列，三次 match 调用将返回值 ["goooooooo"]，["g"] 和 null。
## 用惰性匹配来查找字符
在正则表达式中，贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为懒惰（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。

可以将正则表达式 /t[a-z]*i/ 应用于字符串 "titanic"。 这个正则表达式是一个以 t 开始，以 i 结束，并且中间有一些字母的匹配模式。

正则表达式默认是贪婪匹配，因此匹配返回为 ["titani"]。 它会匹配到适合该匹配模式的最大子字符串。

但是，你可以使用 ? 字符来将其变成懒惰匹配。 调整后的正则表达式 /t[a-z]*?i/ 匹配字符串 "titanic" 返回 ["ti"]。

> **注意**：应该避免使用正则表达式解析 HTML，但是可以用正则表达式匹配 HTML 字符串。
